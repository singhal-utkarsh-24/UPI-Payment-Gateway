




import math
import random
import time
import hashlib
import sys

class RSADemo:
    
    
    @staticmethod
    def generate_keys(p: int, q: int):
        
        n = p * q
        phi = (p - 1) * (q - 1)
        
        
        e = 68  
        
        
        def extended_gcd(a, b):
            if a == 0:
                return b, 0, 1
            else:
                gcd, x, y = extended_gcd(b % a, a)
                return gcd, y - (b // a) * x, x
        
        _, _, d = extended_gcd(e, phi)
        d = d % phi
        if d < 0:
            d += phi
            
        return ((e, n), (d, n))
    
    @staticmethod
    def encrypt(message: int, public_key):
        
        e, n = public_key
        return pow(message, e, n)
    
    @staticmethod
    def decrypt(ciphertext: int, private_key):
        
        d, n = private_key
        return pow(ciphertext, d, n)

class ShorsAlgorithm:
    
    
    @staticmethod
    def find_period(a: int, n: int):
        """
        Find the period of a^x mod n
        In a real quantum computer, this would use quantum Fourier transform
        Here we use classical simulation
        """
        x = 1
        while True:
            if pow(a, x, n) == 1:
                return x
            x += 1
            
            if x > 1000:
                return -1
    
    @staticmethod
    def factor(n: int):
        
        if n % 2 == 0:
            return 2, n // 2
        
        
        a = random.randint(2, n - 1)
        
        
        g = math.gcd(a, n)
        if g > 1:
            return g, n // g
        
        
        r = ShorsAlgorithm.find_period(a, n)
        if r == -1 or r % 2 != 0:
            
            return ShorsAlgorithm.factor(n)
        
        
        x = pow(a, r // 2, n)
        if x == n - 1:
            
            return ShorsAlgorithm.factor(n)
        
        
        factor1 = math.gcd(x - 1, n)
        factor2 = math.gcd(x + 1, n)
        
        if factor1 > 1:
            return factor1, n // factor1
        elif factor2 > 1:
            return factor2, n // factor2
        else:
            
            return ShorsAlgorithm.factor(n)

def generate_sha256_hash(input_string):
    
    return hashlib.sha256(input_string.encode()).hexdigest()

def demonstrate_rsa_pin_vulnerability():
    
    print("\n===== RSA-ENCRYPTED PIN VULNERABILITY DEMONSTRATION =====")
    print("This demonstrates how quantum computers could break RSA encryption")
    print("used to protect PINs in financial systems")
    print("=========================================================\n")
    
    
    pin_str = input("Enter a 4-digit PIN to encrypt: ")
    try:
        pin = int(pin_str)
        if pin < 0 or pin > 9999:
            raise ValueError
    except ValueError:
        print("Invalid PIN. Using default PIN 1234.")
        pin = 1234
    
    
    p, q = 61, 53
    n = p * q
    
    print(f"\nUsing RSA with primes p={p}, q={q}, n={p*q}")
    print("Note: Real RSA uses much larger primes (typically 1024+ bits)")
    
    
    public_key, private_key = RSADemo.generate_keys(p, q)
    
    
    encrypted_pin = RSADemo.encrypt(pin, public_key)
    
    
    
    
    print("\n--- Simulated Quantum Attack using Shor's Algorithm ---")
    print("In a quantum computer, Shor's Algorithm would find the factors of n")
    print(f"Attempting to factor n = {n}...")
    
    start_time = time.time()
    
    try:
        
        found_p, found_q = ShorsAlgorithm.factor(n)
        
        end_time = time.time()
        time_taken = end_time - start_time
        
        print(f"Factored n = {n} into p = {found_p} and q = {found_q}")
        print(f"Time taken: {time_taken:.4f} seconds")
        
        if found_p * found_q == n:
            
            cracked_public_key, cracked_private_key = RSADemo.generate_keys(found_p, found_q)
            
            
            cracked_pin = RSADemo.decrypt(encrypted_pin, cracked_private_key)
            
            if cracked_pin == pin:
                print("\n✓ VULNERABILITY DEMONSTRATED: PIN successfully recovered!")
                print("This shows how quantum computing could break RSA encryption")
                print("and compromise PINs in financial systems.")
            else:
                print("\n * Attack Successful: We have factored n *")
        else:
            print("\n✗ Factorization failed: Product doesn't match n.")
            
    except Exception as e:
        print(f"\n✗ Error during factorization: {e}")

def demonstrate_hash_uid_vulnerability():
    
    print("\n===== SHA-256 HASHED UID VULNERABILITY ANALYSIS =====")
    print("This analyzes how quantum computing affects hash-based authentication")
    print("used for UIDs in financial systems")
    print("======================================================\n")
    
    
    merchant_name = input("Enter merchant name: ")
    if not merchant_name:
        merchant_name = "ExampleMerchant"
        
    password = input("Enter merchant password: ")
    if not password:
        password = "password123"
    
    
    timestamp = str(int(time.time()))
    
    
    hash_input = f"{merchant_name}{timestamp}{password}"
    uid = generate_sha256_hash(hash_input)
    
    print(f"\nMerchant Name: {merchant_name}")
    print(f"Timestamp: {timestamp}")
    print(f"Generated UID: {uid}")
    print(f"UID Length: {len(uid)} characters ({len(uid) * 4} bits)")
    
    
    print("\n--- Quantum Threat Analysis ---")
    print("SHA-256 is vulnerable to quantum attacks through Grover's Algorithm:")
    print("• Classical brute force: 2^256 operations")
    print("• Quantum (Grover's): 2^128 operations - quadratic speedup")
    
    
    print("\n--- Simulated Hash Analysis ---")
    print("While Shor's Algorithm doesn't directly break hash functions,")
    print("it impacts the overall security of systems using both asymmetric")
    print("encryption and hashing.")
    
    print("\nDemonstrating hash properties:")
    
    
    modified_input = f"{merchant_name}_{timestamp}{password}"
    modified_uid = generate_sha256_hash(modified_input)
    
    print(f"Original input: {hash_input}")
    print(f"Original UID: {uid[:16]}...")
    print(f"Modified input: {modified_input}")
    print(f"Modified UID: {modified_uid[:16]}...")
    
    
    matching = sum(1 for a, b in zip(uid, modified_uid) if a == b)
    similarity = (matching / len(uid)) * 100
    
    print(f"Similarity: {similarity:.2f}% ({matching}/{len(uid)} characters match)")
    print("Even a small change in input creates a completely different hash output.")
    
    print("\n--- Post-Quantum Security Implications ---")
    print("1. SHA-256 provides ~128 bits of security against quantum attacks")
    print("2. This is still considered secure in the near term")
    print("3. However, systems relying on both RSA and SHA-256 need to consider")
    print("   that quantum computers could break the RSA component")
    print("4. Recommendation: Transition to quantum-resistant algorithms")
    print("   like SPHINCS+, XMSS, or Lattice-based cryptography")

def main():
    
    print("=====================================================")
    print("  QUANTUM VULNERABILITY DEMONSTRATION")
    print("  Showing how Shor's Algorithm threatens classical")
    print("  cryptography used in financial systems")
    print("=====================================================")
    
    while True:
        print("\nSelect a demonstration:")
        print("1. RSA-encrypted PIN vulnerability")
        
        choice = input("\nEnter 1 to continue: ")
        
        if choice == "1":
            demonstrate_rsa_pin_vulnerability()
        elif choice == "2":
            demonstrate_hash_uid_vulnerability()
        elif choice == "3":
            print("\nExiting demonstration. Thank you!")
            break
        else:
            print("Invalid choice. Please select 1, 2, or 3.")

if __name__ == "__main__":
    main()
